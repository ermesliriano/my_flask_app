- hosts: deploy_servers
  become: true  # Ejecutar con privilegios de sudo (root)
  vars:
    app_name: "mi-aplicacion"                   # Nombre lógico de la app/imagen
    container_name: "mi-aplicacion"             # Nombre del contenedor en ejecución
    app_port: "8080"                            # Puerto interno de la app en el container
    version: "{{ desired_version }}"            # Versión/tag de la imagen a desplegar (pasado externamente)
  tasks:
    # 1. Instalar Docker Engine (y dependencias) en el servidor
    - name: Instalar paquetes de Docker
      apt:
        update_cache: yes
        pkg:
          - apt-transport-https
          - ca-certificates
          - curl
          - gnupg
          - lsb-release
      when: ansible_os_family == "Debian"

    - name: Añadir clave GPG oficial de Docker
      apt_key:
        url: https://download.docker.com/linux/ubuntu/gpg
        state: present

    - name: Añadir repositorio APT de Docker
      apt_repository:
        repo: "deb [arch=amd64] https://download.docker.com/linux/ubuntu {{ ansible_lsb.codename }} stable"
        state: present

    - name: Instalar Docker Engine
      apt:
        name:
          - docker-ce
          - docker-ce-cli
          - containerd.io
        state: present

    - name: Habilitar y asegurar que Docker está iniciado
      systemd:
        name: docker
        state: started
        enabled: yes

    - name: Instalar SDK de Docker para Python (para módulos Ansible)
      pip:
        name: docker
        state: present

    # 2. Construir la nueva imagen Docker de la aplicación (usando la versión indicada)
    - name: Copiar código fuente/artefacto de la aplicación al servidor
      synchronize:
        src: "./"                # Ruta local del código/artefacto (Jenkins workspace)
        dest: "/opt/{{app_name}}"  # Ruta en el servidor de despliegue
        delete: no

    - name: Construir imagen Docker {{ app_name }}:{{ version }}
      community.docker.docker_image:
        name: "{{ app_name }}"
        tag: "{{ version }}"
        build:
          path: "/opt/{{ app_name }}"
      register: build_result

    # 3. Desplegar contenedor con la nueva imagen
    - name: Detener contenedor previo (si existe)
      community.docker.docker_container:
        name: "{{ container_name }}"
        state: stopped
      ignore_errors: yes   # Ignorar error si el contenedor no existía

    - name: Eliminar contenedor previo (si existe) para liberar nombre/puerto
      community.docker.docker_container:
        name: "{{ container_name }}"
        state: absent
      ignore_errors: yes

    - name: Ejecutar nuevo contenedor {{ container_name }} con versión {{ version }}
      community.docker.docker_container:
        name: "{{ container_name }}"
        image: "{{ app_name }}:{{ version }}"
        state: started
        restart_policy: unless-stopped
        published_ports:
          - "80:{{ app_port }}"      # publicar puerto (host:contenedor) ej. 80->8080 interno
        env:
          APP_ENV: "produccion"      # (ejemplo) variables de entorno necesarias en el contenedor
        # volumes:
        #   - "/ruta/host:/ruta/contenedor"   # (ejemplo) montar volúmenes persistentes si aplica

    - name: Comprobar que el nuevo contenedor responde en el puerto 80
      wait_for:
        host: "localhost"
        port: 80
        timeout: 30
      register: http_check
      # (Opcional: se podría usar uri: para verificar una URL de health-check específica)

    - name: Verificar respuesta HTTP del contenedor (código 200 OK)
      uri:
        url: "http://localhost:80/health"
        status_code: 200
      register: health_response
      retries: 5
      delay: 3
      ignore_errors: yes

    - name: Validar estado de salud del nuevo despliegue
      fail:
        msg: "La nueva versión no pasó el check de salud, iniciando rollback"
      when: health_response.status is not defined or health_response.status != 200

    # 4. (Opcional) Implementar rollback automático si el health-check falló
    - block:
        - name: Restaurar versión anterior en caso de fallo
          community.docker.docker_container:
            name: "{{ container_name }}"
            image: "{{ app_name }}:{{ previous_version }}"
            state: started
            published_ports:
              - "80:{{ app_port }}"
            restart_policy: unless-stopped
      when: health_response.status is not defined or health_response.status != 200
      rescue:
        - debug:
            msg: "Rollback: Se desplegó nuevamente la versión anterior ({{ previous_version }})"
