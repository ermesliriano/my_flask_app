---
- name: Desplegar aplicación Flask en Docker
  hosts: all
  become: true

  vars:
    app_name: "my-flask-app"
    container_name: "my-flask-app"
    docker_image: ""                   # Lo recibe Jenkins como -e docker_image=...
    app_port: 5000
    host_port: 5000
    healthcheck_url: "http://localhost:5000/health"

  collections:
    - community.docker

  pre_tasks:
    - name: Asegurar paquetes base (Debian/Ubuntu)
      apt:
        name: [python3, python3-pip, ca-certificates, curl, gnupg, lsb-release]
        update_cache: yes
      when: ansible_os_family == "Debian"

    - name: Añadir clave GPG oficial de Docker
      apt_key:
        url: https://download.docker.com/linux/ubuntu/gpg
        state: present
      when: ansible_os_family == "Debian"

    - name: Añadir repo Docker
      apt_repository:
        repo: "deb [arch=amd64] https://download.docker.com/linux/ubuntu {{ ansible_lsb.codename }} stable"
        state: present
      when: ansible_os_family == "Debian"

    - name: Instalar Docker Engine
      apt:
        name: [docker-ce, docker-ce-cli, containerd.io]
        state: present
      when: ansible_os_family == "Debian"

    - name: Habilitar y arrancar Docker
      systemd:
        name: docker
        state: started
        enabled: yes

    # En Debian/Ubuntu instala el SDK oficial desde repos
    - name: Instalar SDK Docker para Python (Debian/Ubuntu)
      apt:
        name: python3-docker
        state: present
        update_cache: yes
      when: ansible_os_family == "Debian"

  tasks:
    - block:
        - name: Obtener info del contenedor actual (si existe)
          community.docker.docker_container_info:
            name: "{{ container_name }}"
          register: current_container
          failed_when: false

        - name: Guardar imagen previa si existe contenedor
          set_fact:
            prev_image: "{{ current_container.container.Image }}"
          when: current_container.container is defined

        - name: Eliminar contenedor previo (si existe)
          community.docker.docker_container:
            name: "{{ container_name }}"
            state: absent
          ignore_errors: true

        - name: Asegurar que la nueva imagen está en el host (pull)
          community.docker.docker_image:
            name: "{{ docker_image }}"
            source: pull

        - name: Desplegar contenedor con la nueva imagen
          community.docker.docker_container:
            name: "{{ container_name }}"
            image: "{{ docker_image }}"
            state: started
            detach: true
            recreate: true
            restart_policy: unless-stopped
            ports:
              - "{{ host_port }}:{{ app_port }}"

        - name: Health-check HTTP
          uri:
            url: "{{ healthcheck_url }}"
            status_code: 200
            timeout: 5
          register: healthcheck
          retries: 5
          delay: 3
          until: healthcheck.status == 200

        - name: Confirmación de despliegue exitoso
          debug:
            msg: "Despliegue OK de {{ docker_image }} (health-check 200)."

      rescue:
        - name: Restaurar contenedor con la imagen previa
          community.docker.docker_container:
            name: "{{ container_name }}"
            image: "{{ prev_image | default('') }}"
            state: started
            detach: true
            restart_policy: unless-stopped
            ports:
              - "{{ host_port }}:{{ app_port }}"
          when: prev_image is defined

        - name: Fallar play para que Jenkins lo marque como FAILURE
          fail:
            msg: "Health-check falló. Se restauró la versión anterior: {{ prev_image | default('N/A') }}"
